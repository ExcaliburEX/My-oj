/*
小明正在玩一个“翻硬币”的游戏。

桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。

比如，可能情形是：**oo***oooo

如果同时翻转左边的两个硬币，则变为：oooo***oooo

现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？
我们约定：把翻动相邻的两个硬币叫做一步操作，那么要求：

程序输入：
两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度<1000

程序输出：
一个整数，表示最小操作步数

例如：
用户输入：
**********
o****o****

程序应该输出：
5

再例如：
用户输入：
*o**o***o***
*o***o**o***

程序应该输出：
1

资源约定：
峰值内存消耗 < 64M
CPU消耗 < 1000ms

请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。

提交时，注意选择所期望的编译器类型。
*/
#include <stdio.h>
#include <stdlib.h>
#include<string.h>
int turn(char a[], char b[])
{
	int i;
	int n = 0;
	for (i = 0; a[i] != '\0'; i++)
	{
		if (a[i] == b[i])
		{
			continue;
		}
		else
		{
			b[i]= (b[i] == '*' ? 'o' : '*');
			b[i + 1] = (b[i + 1] == '*' ? 'o' : '*');  //此处用到三目运算符 
			n++;
		}
		printf("第%d次变换：\n", n);
		for (int i = 0; i < strlen(a); i++)
		{
			printf("%c", a[i]);
		}
		printf("\n");
		for (int i = 0; i < strlen(b); i++)
		{
			printf("%c", b[i]);
		}
		printf("\n");
	}
	return n;
}

int main(void)
{
	char a[1000];
	char b[1000];
	gets_s(a);
	gets_s(b);
	printf("%d\n", turn(a, b));
	return 0;
}